Структурные паттерны проектирования
Структурные паттерны проектирования помогают организовать классы и объекты в более крупные структуры, сохраняя при этом гибкость и эффективность системы. Они решают задачи композиции классов и объектов.

Основные структурные паттерны
Адаптер (Adapter):

Позволяет объектам с несовместимыми интерфейсами работать вместе.

Пример: Адаптер для подключения старого принтера к новой системе.

Мост (Bridge):

Разделяет абстракцию и реализацию, позволяя им изменяться независимо.

Пример: Разделение графического интерфейса и платформы (Windows, macOS).

Компоновщик (Composite):

Позволяет работать с отдельными объектами и их композициями единообразно.

Пример: Древовидная структура файлов и папок.

Декоратор (Decorator):

Динамически добавляет объектам новые обязанности.

Пример: Добавление функциональности к объекту (например, добавление молока к кофе).

Фасад (Facade):

Предоставляет упрощенный интерфейс к сложной системе.

Пример: Упрощение работы с библиотекой для работы с базами данных.

Приспособленец (Flyweight):

Экономит память, разделяя общее состояние между множеством объектов.

Пример: Хранение общих данных для символов в текстовом редакторе.

Заместитель (Proxy):

Позволяет контролировать доступ к объекту.

Пример: Ленивая загрузка изображений.

Подробное рассмотрение двух паттернов
1. Адаптер (Adapter)
Проблема:
У вас есть класс LegacyPrinter, который имеет метод print_text, но вам нужно использовать его в системе, которая ожидает объект с методом print.

Решение:
Создайте класс ModernPrinter, который адаптирует интерфейс LegacyPrinter к новому интерфейсу.

Диаграмма классов:

Copy
+----------------+          +----------------+
|  LegacyPrinter |          |  ModernPrinter |
+----------------+          +----------------+
| + print_text() |<-------->| + print()      |
+----------------+          +----------------+
Код:

ruby
Copy
class LegacyPrinter
  def print_text(text)
    puts "Legacy Printer: #{text}"
  end
end

class ModernPrinter
  def initialize(printer)
    @printer = printer
  end

  def print(text)
    @printer.print_text(text)
  end
end

legacy_printer = LegacyPrinter.new
modern_printer = ModernPrinter.new(legacy_printer)
modern_printer.print("Hello, World!") # Legacy Printer: Hello, World!
Связь с другими паттернами:

Декоратор: Адаптер изменяет интерфейс объекта, а декоратор добавляет новые обязанности.

Фасад: Адаптер адаптирует один интерфейс к другому, а фасад предоставляет упрощенный интерфейс к сложной системе.

2. Декоратор (Decorator)
Проблема:
У вас есть класс Coffee, и вы хотите динамически добавлять к нему новые возможности, такие как добавление молока или сахара, без изменения исходного класса.

Решение:
Создайте классы-декораторы, которые добавляют новые возможности к объекту Coffee.

Диаграмма классов:

Copy
+----------------+          +----------------+
|     Coffee     |          |  CoffeeDecorator |
+----------------+          +----------------+
| + cost()       |<-------->| + cost()         |
+----------------+          +----------------+
       ^
       |
+----------------+
|  MilkDecorator |
+----------------+
| + cost()       |
+----------------+
Код:

ruby
Copy
class Coffee
  def cost
    5
  end
end

class MilkDecorator
  def initialize(coffee)
    @coffee = coffee
  end

  def cost
    @coffee.cost + 2
  end
end

class SugarDecorator
  def initialize(coffee)
    @coffee = coffee
  end

  def cost
    @coffee.cost + 1
  end
end

coffee = Coffee.new
puts "Cost: #{coffee.cost}" # Cost: 5

milk_coffee = MilkDecorator.new(coffee)
puts "Cost: #{milk_coffee.cost}" # Cost: 7

sugar_milk_coffee = SugarDecorator.new(milk_coffee)
puts "Cost: #{sugar_milk_coffee.cost}" # Cost: 8
Связь с другими паттернами:

Адаптер: Декоратор изменяет поведение объекта, а адаптер изменяет его интерфейс.

Компоновщик: Декоратор может использоваться для добавления функциональности к объектам в композиции.

Итог
Адаптер и Декоратор — это мощные структурные паттерны, которые помогают решать задачи совместимости и расширения функциональности.

Адаптер изменяет интерфейс объекта, чтобы он мог работать с другим кодом.

Декоратор добавляет новые обязанности объекту, не изменяя его исходный класс.