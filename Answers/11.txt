Поведенческие паттерны проектирования
Поведенческие паттерны проектирования решают задачи взаимодействия объектов и распределения ответственности между ними. Они помогают сделать систему более гибкой и легко расширяемой.

Основные поведенческие паттерны
Цепочка обязанностей (Chain of Responsibility):

Позволяет передавать запросы по цепочке обработчиков.

Пример: Обработка запросов в веб-приложении.

Команда (Command):

Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами.

Пример: Управление действиями в текстовом редакторе.

Итератор (Iterator):

Предоставляет способ последовательного доступа к элементам составного объекта.

Пример: Обход элементов коллекции.

Посредник (Mediator):

Упрощает взаимодействие между объектами, инкапсулируя их взаимодействие в одном объекте.

Пример: Чат-комната, где посредник управляет сообщениями между пользователями.

Снимок (Memento):

Позволяет сохранять и восстанавливать состояние объекта.

Пример: Отмена действий в текстовом редакторе.

Наблюдатель (Observer):

Позволяет объектам подписываться на события и получать уведомления об изменениях.

Пример: Подписка на новости.

Состояние (State):

Позволяет объекту изменять свое поведение при изменении его состояния.

Пример: Управление состоянием заказа (новый, в процессе, завершен).

Стратегия (Strategy):

Позволяет выбирать алгоритм во время выполнения программы.

Пример: Выбор способа оплаты (кредитная карта, PayPal).

Шаблонный метод (Template Method):

Определяет скелет алгоритма, позволяя подклассам переопределять некоторые шаги.

Пример: Процесс приготовления напитка (кофе, чай).

Посетитель (Visitor):

Позволяет добавлять новые операции к объектам без изменения их классов.

Пример: Обход структуры данных и выполнение операций над каждым элементом.

Подробное рассмотрение двух паттернов
1. Наблюдатель (Observer)
Проблема:
У вас есть объект, который должен уведомлять другие объекты об изменениях своего состояния. Вы хотите сделать это без жесткой привязки между объектами.

Решение:
Создайте механизм подписки, где объекты могут подписываться на события и получать уведомления.

Диаграмма классов:

Copy
+----------------+          +----------------+
|    Subject     |          |    Observer    |
+----------------+          +----------------+
| + attach()     |<-------->| + update()     |
| + detach()     |          +----------------+
| + notify()     |
+----------------+
       ^
       |
+----------------+
| ConcreteSubject|
+----------------+
| + state        |
+----------------+
Код:

ruby
Copy
class Subject
  attr_accessor :observers

  def initialize
    @observers = []
  end

  def attach(observer)
    @observers << observer
  end

  def detach(observer)
    @observers.delete(observer)
  end

  def notify
    @observers.each { |observer| observer.update(self) }
  end
end

class Observer
  def update(subject)
    raise NotImplementedError
  end
end

class ConcreteObserver < Observer
  def update(subject)
    puts "Observer received update from #{subject}"
  end
end

subject = Subject.new
observer = ConcreteObserver.new
subject.attach(observer)
subject.notify # Observer received update from #<Subject:0x00007f8e1d0b0e80>
Связь с другими паттернами:

Медиатор: Наблюдатель может быть использован для реализации взаимодействия между объектами через посредника.

Команда: Наблюдатель может использовать команды для выполнения действий при получении уведомлений.

2. Стратегия (Strategy)
Проблема:
У вас есть несколько алгоритмов, и вы хотите выбирать один из них во время выполнения программы. Вы не хотите жестко привязывать код к конкретному алгоритму.

Решение:
Создайте семейство алгоритмов, инкапсулируйте каждый из них и сделайте их взаимозаменяемыми.

Диаграмма классов:

Copy
+----------------+          +----------------+
|    Context     |          |    Strategy    |
+----------------+          +----------------+
| + strategy     |<-------->| + execute()    |
+----------------+          +----------------+
                                   ^
                                   |
                            +----------------+
                            | ConcreteStrategy|
                            +----------------+
                            | + execute()    |
                            +----------------+
Код:

ruby
Copy
class Strategy
  def execute
    raise NotImplementedError
  end
end

class ConcreteStrategyA < Strategy
  def execute
    puts "Executing Strategy A"
  end
end

class ConcreteStrategyB < Strategy
  def execute
    puts "Executing Strategy B"
  end
end

class Context
  attr_accessor :strategy

  def initialize(strategy)
    @strategy = strategy
  end

  def execute_strategy
    @strategy.execute
  end
end

context = Context.new(ConcreteStrategyA.new)
context.execute_strategy # Executing Strategy A

context.strategy = ConcreteStrategyB.new
context.execute_strategy # Executing Strategy B
Связь с другими паттернами:

Состояние: Стратегия может быть использована для изменения поведения объекта в зависимости от его состояния.

Команда: Стратегия может быть реализована как команда, которая инкапсулирует алгоритм.

Итог
Наблюдатель и Стратегия — это мощные поведенческие паттерны, которые помогают решать задачи взаимодействия объектов и выбора алгоритмов.

Наблюдатель позволяет объектам подписываться на события и получать уведомления об изменениях.

Стратегия позволяет выбирать алгоритм во время выполнения программы.