Ассоциация - в поле экземпляра одного класса лежит экземпляр другого класса.
Три частных случая ассоциации:
Агрегация и Композиция - Быть частью. Двигатель является частью автомобиля.
Разница:
Агрегация - экземпляр двигателя может существовать отдельно от экземпляра автомобиля. Составная часть может существовать отдельно от целого. 
В коде: внутрь класса внешнего передаём уже созданный экземпляр составной части. Создали Жвигатель вне Аавтомобиля и кинули в Автомобиль аргументом.


Композиция - составная часть не может существовать вне целого.
В коде: составной класс создаётся ВНутри внешнего целого класса. Внутри вызывается Двигатель.New.

Делегация - один из способов реализации рефакторинга повтора кода. Такое же отношение как и наследование и решает задачу повтора кода.
Делегация — это паттерн проектирования, при котором один объект передает часть своих обязанностей или задач другому объекту.
Предположим, у нас есть класс Printer, который отвечает за печать документов, и класс Scanner, который отвечает за сканирование документов. Вместо того чтобы создавать класс PrinterScanner, который наследует оба класса, мы можем использовать делегацию.
class Printer:
    def print_document(self, document):
        print(f"Printing: {document}")

class Scanner:
    def scan_document(self):
        print("Scanning document")
        return "Scanned document"

class PrinterScanner:
    def __init__(self):
        self.printer = Printer()
        self.scanner = Scanner()

    def print_document(self, document):
        self.printer.print_document(document)

    def scan_document(self):
        return self.scanner.scan_document()

# Использование
printer_scanner = PrinterScanner()
printer_scanner.print_document("My Document")
scanned_doc = printer_scanner.scan_document()
print(scanned_doc)

Класс PrinterScanner делегирует задачи печати и сканирования объектам Printer и Scanner соответственно.

Мы избегаем дублирования кода и можем легко изменять или заменять функциональность, связанную с печатью или сканированием, не изменяя класс PrinterScanner.